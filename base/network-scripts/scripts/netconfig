#!/bin/sh
# A script to do basic network configuration.
# Mostly written by Patrick Volkerding <volkerdi@slackware.com>.
# Modified to use /etc/rc.d/rc.inet1.conf Tue Aug 26 16:51:48 PDT 2003 <pjv>

write_config_files() {
#
############################################################################
#			  The rc.inet1.conf file.
############################################################################
#

# If we're doing loopback, we don't want 127.0.0.1 and 255.255.255.0 in
# rc.inet1.conf... it's better to leave the values null.  However, since
# we use the IP in other places, we need to make a copy for here.
RCIPCOPY=$IPADDR
RCMASKCOPY=$NETMASK
if [ "$RCIPCOPY" = "127.0.0.1" ]; then
  RCIPCOPY=""
  RCMASKCOPY=""
fi

# echo "Creating /$RC..."
/bin/cat << ENDFILE > $RC
# /etc/rc.d/rc.inet1.conf
#
# This file contains the configuration settings for network interfaces.
# If USE_DHCP[interface] is set to "yes", this overrides any other settings.
# If you don't have an interface, leave the settings null ("").

# You can configure network interfaces other than eth0,eth1... by setting
# IFNAME[interface] to the interface's name. If IFNAME[interface] is unset
# or empty, it is assumed you're configuring eth<interface>.

# Several other parameters are available, the end of this file contains a
# comprehensive set of examples.

# =============================================================================

# Config information for eth0:
IPADDR[0]="$RCIPCOPY"
NETMASK[0]="$RCMASKCOPY"
USE_DHCP[0]="$USE_DHCP"
DHCP_HOSTNAME[0]="$DHCP_HOSTNAME"

# Config information for eth1:
IPADDR[1]=""
NETMASK[1]=""
USE_DHCP[1]=""
DHCP_HOSTNAME[1]=""

# Config information for eth2:
IPADDR[2]=""
NETMASK[2]=""
USE_DHCP[2]=""
DHCP_HOSTNAME[2]=""

# Config information for eth3:
IPADDR[3]=""
NETMASK[3]=""
USE_DHCP[3]=""
DHCP_HOSTNAME[3]=""

# Default gateway IP address:
GATEWAY="$GATEWAY"

# Change this to "yes" for debugging output to stdout.  Unfortunately,
# /sbin/hotplug seems to disable stdout so you'll only see debugging output
# when rc.inet1 is called directly.
DEBUG_ETH_UP="no"

## Example config information for wlan0.  Uncomment the lines you need and fill
## in your info.  (You may not need all of these for your wireless network)
#IFNAME[4]="wlan0"
#IPADDR[4]=""
#NETMASK[4]=""
#USE_DHCP[4]="yes"
#DHCP_HOSTNAME[4]="icculus-wireless"
#DHCP_KEEPRESOLV[4]="yes"
#DHCP_KEEPNTP[4]="yes"
#DHCP_KEEPGW[4]="yes"
#DHCP_IPADDR[4]=""
#WLAN_ESSID[4]=BARRIER05
#WLAN_MODE[4]=Managed
##WLAN_RATE[4]="54M auto"
##WLAN_CHANNEL[4]="auto"
##WLAN_KEY[4]="D5AD1F04ACF048EC2D0B1C80C7"
##WLAN_IWPRIV[4]="set AuthMode=WPAPSK | set EncrypType=TKIP | set WPAPSK=96389dc66eaf7e6efd5b5523ae43c7925ff4df2f8b7099495192d44a774fda16"
#WLAN_WPA[4]="wpa_supplicant"
#WLAN_WPADRIVER[4]="ndiswrapper"

## Some examples of additional network parameters that you can use.
## Config information for wlan0:
#IFNAME[4]="wlan0"              # Use a different interface name nstead of
                                # the default 'eth4'
#HWADDR[4]="00:01:23:45:67:89"  # Overrule the card's hardware MAC address
#MTU[4]=""                      # The default MTU is 1500, but you might need
                                # 1360 when you use NAT'ed IPSec traffic.
#DHCP_KEEPRESOLV[4]="yes"       # If you dont want /etc/resolv.conf overwritten
#DHCP_KEEPNTP[4]="yes"          # If you don't want ntp.conf overwritten
#DHCP_KEEPGW[4]="yes"           # If you don't want the DHCP server to change
                                # your default gateway
#DHCP_IPADDR[4]=""              # Request a specific IP address from the DHCP
                                # server
#WLAN_ESSID[4]=DARKSTAR         # Here, you can override _any_ parameter
                                # defined in rc.wireless.conf, by prepending
                                # 'WLAN_' to the parameter's name. Useful for
                                # those with multiple wireless interfaces.
#WLAN_IWPRIV[4]="set AuthMode=WPAPSK | set EncrypType=TKIP | set WPAPSK=thekey"
                                # Some drivers require a private ioctl to be
                                # set through the iwpriv command. If more than
                                # one is required, you can place them in the
                                # IWPRIV parameter (separated with the pipe (|)
                                # character, see the example).
ENDFILE
#
############################################################################
#			  The networks file.
############################################################################
#
#echo "Creating /$ETCNETWORKS..."
/bin/cat <<EOF >$ETCNETWORKS
#
# networks	This file describes a number of netname-to-address
#		mappings for the TCP/IP subsystem.  It is mostly
#		used at boot time, when no name servers are running.
#

loopback	127.0.0.0
localnet	$NETWORK

# End of networks.
EOF
chmod 644 $ETCNETWORKS
#
############################################################################
#			   The hosts file.
############################################################################
#
#echo "Creating /$HOSTS..."
/bin/cat << EOF > $HOSTS
#
# hosts		This file describes a number of hostname-to-address
#		mappings for the TCP/IP subsystem.  It is mostly
#		used at boot time, when no name servers are running.
#		On small systems, this file can be used instead of a
#		"named" name server.  Just add the names, addresses
#		and any aliases to this file...
#
# By the way, Arnt Gulbrandsen <agulbra@nvg.unit.no> says that 127.0.0.1
# should NEVER be named with the name of the machine.  It causes problems
# for some (stupid) programs, irc and reputedly talk. :^)
#

# For loopbacking.
127.0.0.1		localhost
$IPADDR		$HOSTNM.$DOMAIN $HOSTNM

# End of hosts.

EOF
chmod 644 $HOSTS
#
############################################################################
#			The resolv.conf file.
############################################################################
#
if [ ! "$NAMESERVER" = "" ]; then
  echo "search $DOMAIN" >$RESOLV
  echo "nameserver $NAMESERVER" >>$RESOLV
else
  echo "search $DOMAIN" >$RESOLV
fi
if [ -f $RESOLV ]; then
  chmod 644 $RESOLV
fi
#
############################################################################
#			The rc.netdevice file.
############################################################################
#
if [ -r /cardfound ]; then
  if [ ! "`cat /cardfound`" = "" ]; then
    cat << EOF > etc/rc.d/rc.netdevice
# Load module for network device.
# This script is automatically generated during the installation.

/sbin/modprobe `cat /cardfound`

EOF
    chmod 755 etc/rc.d/rc.netdevice
  fi
fi
rm -f $TMP/tempmsg /cardfound
} # end write_config_files

TMP=/var/log/setup/tmp
if [ ! -d $TMP ]; then
 mkdir -p $TMP
 chmod 700 $TMP
fi

# This checks IP address syntax.
# usage: syntax_check ADDRESS #-OF-EXPECTED-SEGMENTS (up to 4)
# example: syntax_check 123.22.43.1 4
# returns: 0=found correct  1=too many fields  2=non numeric field found
syntax_check_color() {
  RET_CODE=0 
  SCRATCH=$1
  SCRATCH=`echo $SCRATCH | tr "." "/"`
  INDEX=$2
  while [ ! "$INDEX" = "0" ]; do
    # OK, so I'm a LISP-head :^)
    FIELD=`basename $SCRATCH`
    SCRATCH=`dirname $SCRATCH`
    if expr $FIELD + 1 1> /dev/null 2> /dev/null; then
      true
    else
      RET_CODE=2; # non-numeric field
    fi
    INDEX=`expr $INDEX - 1`
  done
  if [ ! "$SCRATCH" = "." ]; then
    RET_CODE=1; # too many arguments
  fi
  if [ "$3" = "WARN" -a ! "$RET_CODE" = "0" ]; then
    cat << EOF > $TMP/tempmsg

L'adresse que vous avez entrée ne semble pas standard. Le programme s'attendait
a $2 groupes de nombres séparés par des points, comme « 127.0.0.1 ».
Procéder tout de même à l'affectation de l'adresse $1 ?

EOF
    dialog --title "ATTENTION" --yesno "`cat $TMP/tempmsg`" 9 72
    if [ $? = 0 ]; then
      RET_CODE = 0;
    fi
    rm -r $TMP/tempmsg
  else
    if [ "$3" = "ECHO" ]; then
      echo $RET_CODE;
    fi
  fi
  return $RET_CODE;
}

# Figure out where we are...  cheap hack.
if [ ! -e etc/slackware-version -a ! -e /etc/installer -a ! -e bin/bash ]; then
  cd /
fi;

# IMPORTANT!!! NO LEADING '/' in the paths below, or this script will not
# function from the bootdisk.
RC=etc/rc.d/rc.inet1.conf		# Where rc.inet1.conf file is.
RESOLV=etc/resolv.conf			# Where resolv.conf file is.
HOSTS=etc/hosts			 	# Where hosts file is.
ETCNETWORKS=etc/networks		# Where networks file is.
USE_DHCP=""                             # Use DHCP?  "" == no.
DHCP_HOSTNAME=""                        # This is our DHCP hostname.
#
# defaults:
NETWORK=127.0.0.0
IPADDR=127.0.0.1
NETMASK=255.255.255.0


# Main loop:
while [ 0 ]; do
cat << EOF > $TMP/tempmsg
Donnons d'abord un nom d'hôte a votre machine.
Le nom d'hôte *uniquement* est requis (sans le nom de domaine).

Entrez le nom d'hôte :
EOF
 dialog --title "NOM D'HÔTE" --inputbox "`cat $TMP/tempmsg`" 11 65 \
 $HOSTNM 2> $TMP/SeThost
 if [ $? = 1 -o $? = 255 ]; then
  rm -f $TMP/SeThost $TMP/tempmsg
  exit
 fi
 HOSTNM="`cat $TMP/SeThost`"
 rm -f $TMP/SeThost $TMP/tempmsg
 if [ ! "$HOSTNM" = "" ]; then
  break;
 fi
done

while [ 0 ]; do
cat << EOF > $TMP/tempmsg
Définissons à présent le nom de domaine de cette machine, comme par exemple :

exemple.fr

Ne commencez *pas* la ligne par un point '.' .

Entrez le nom de domaine pour $HOSTNM :
EOF
 dialog --title "NOM DE DOMAINE POUR '$HOSTNM'" --inputbox \
"`cat $TMP/tempmsg`" \
14 64 $DOMAIN 2> $TMP/SeTdom
 if [ $? = 1 -o $? = 255 ]; then
  rm -f $TMP/SeTdom $TMP/tempmsg
  exit
 fi
 DOMAIN="`cat $TMP/SeTdom`"
 rm -f $TMP/SeTdom $TMP/tempmsg
 if [ ! "$DOMAIN" = "" ]; then
  break;
 fi
done

echo $HOSTNM.$DOMAIN > etc/HOSTNAME

dialog --title "DÉFINITION DE L'ADRESSE IP DE '$HOSTNM.$DOMAIN'" \
--default-item DHCP \
--menu \
"Comment votre machine se conecte-t-elle au réseau ?\n\
Si vous avez une carte réseau interne ayant une IP définie, une passerelle \
ou un routeur ainsi qu'un serveur DNS, choisissez 'IP statique' et entrez \
votre configuration. Si votre IP est assignée par un serveur DHCP (comme \
beaucoup de fournisseurs d'accès ADSL/câble le font), choisissez 'DHCP'. \
Si vous n'avez pas de carte réseau, choisissez 'Loopback'. 'Loopback' est \
également correcte si votre seule connexion au réseau passe par un modem sur \
port série (avec SLIP ou PPP) ou bien si vous utilisez un PC portable (les \
cartes PCMCIA sont configurées dans /etc/pcmcia/) équipé en PCMCIA. Quel type 
de connexion correspond le plus à votre machine ?" 20 70 3 \
"IP statique" "Utiliser une IP statique pour configurer le réseau Ethernet" \
"DHCP" "Utiliser un serveur DHCP pour configurer le réseau Ethernet" \
"Loopback" "Définir une connexion en loopback (modem ou aucun réseau)" 2> $TMP/reply
if [ $? = 1 -o $? = 255 ]; then
  rm -f $TMP/reply
  exit
fi
REPLY=`cat $TMP/reply`
rm -f $TMP/reply

if [ "$REPLY" = "DHCP" ]; then
  USE_DHCP="yes"
  dialog --title "DÉFINIR LE NOM D'HÔTE DHCP"  --inputbox "Certains fournisseurs \
nécessitent un nom d'hôte DHCP pour la connexion. Si c'est le cas, un nom d'hôte a \
été affecté à votre machine, lequel ressemble à quelque chose comme CC-NOMBRE-A \
(cela dépend de votre fournisseur). Si un nom d'hôte est affecté à vote machine, \
entrez-le ci-dessous. Si aucun nom d'hôte n'a été affecté, appuyez simplement \
sur ENTRÉE ou annulez." 13 62 \
2> $TMP/SeTDHCPHOST
  NEW_DHCPHOST="`cat $TMP/SeTDHCPHOST`"
  rm -f $TMP/SeTDHCPHOST
  # OK, if we actually got something, use it.
  DHCP_HOSTNAME="$NEW_DHCPHOST"
elif [ "$REPLY" = "Loopback" ]; then
  LOOPBACK="yes"
else
  LOOPBACK="no"
fi

if [ "$LOOPBACK" = "no" -a ! "$USE_DHCP" = "yes" ]; then

 while [ 0 ]; do
  if [ -r $TMP/SeTIP ]; then
   IPADDR=`cat $TMP/SeTIP`
  fi
  cat << EOF > $TMP/tempmsg
Entrez l'adresse IP de votre machine. Exemple :
192.168.0.10
Adresse IP de $HOSTNM (aaa.bbb.ccc.ddd) : 
EOF
  dialog --title "ADRESSE IP DE '$HOSTNM.$DOMAIN'" --inputbox \
"`cat $TMP/tempmsg`" \
10 68 $IPADDR 2> $TMP/SeTlip
  if [ $? = 1 -o $? = 255 ]; then
   rm -f $TMP/SeTlip $TMP/tempmsg
   exit
  fi
  IPADDR="`cat $TMP/SeTlip`"
  rm -f $TMP/SeTlip $TMP/tempmsg
  if [ "$IPADDR" = "" ]; then
   continue;
  fi
  syntax_check_color $IPADDR 4 WARN
  if [ $? = 0 ]; then
   echo $IPADDR > $TMP/SeTIP
   break;
  fi
 done

 while [ 0 ]; do
  if [ -r $TMP/SeTnetmask ]; then
   NETMASK=`cat $TMP/SeTnetmask`
  fi
  cat << EOF > $TMP/tempmsg
Entrez votre masque de sous-réseau. Cela ressemble généralement à quelque
chose comme : 255.255.255.0
Masque de sous-réseau (aaa.bbb.ccc.ddd) :
EOF
  dialog --title "MASQUE DE SOUS-RÉSEAU LOCAL" --inputbox \
"`cat $TMP/tempmsg`" \
10 65 $NETMASK 2> $TMP/SeTnmask
  if [ $? = 1 -o $? = 255 ]; then
   rm -f $TMP/SeTnmask $TMP/tempmsg
   exit
  fi
  NETMASK="`cat $TMP/SeTnmask`"
  rm -f $TMP/SeTnmask $TMP/tempmsg
  if [ "$NETMASK" = "" ]; then
   continue;
  fi
  syntax_check_color $NETMASK 4 WARN
  if [ $? = 0 ]; then
   echo $NETMASK > $TMP/SeTnetmask
   break;
  fi
 done
 
 # Set broadcast/network addresses automatically:
 BROADCAST=`ipmask $NETMASK $IPADDR | cut -f 1 -d ' '`
 NETWORK=`ipmask $NETMASK $IPADDR | cut -f 2 -d ' '`

 while [ 0 ]; do
  if [ -r $TMP/SeTgateway ]; then
   GATEWAY=`cat $TMP/SeTgateway`
  fi
  cat << EOF > $TMP/tempmsg
Entrez l'adresse de la passerelle ou du routeur de votre réseau, telle que :
`echo $IPADDR | cut -f 1-3 -d .`.1

Si vous n'avez pas de passerelle/routeur sur votre réseau, appuyez simplement
sur ENTRÉE sans entrer d'IP.

Adresse IP de passerelle/routeur (aaa.bbb.ccc.ddd) :
EOF
  dialog --title "ADRESSE DE LA PASSERELLE/ROUTEUR" --inputbox "`cat $TMP/tempmsg`" \
  14 64 $GATEWAY 2> $TMP/SeTgate
  if [ $? = 1 -o $? = 255 ]; then
   rm -f $TMP/SeTgate $TMP/tempmsg
   exit
  fi
  GATEWAY="`cat $TMP/SeTgate`"
  rm -f $TMP/SeTgate $TMP/tempmsg
  if [ "$GATEWAY" = "" ]; then
    echo > $TMP/SeTgateway
    break;
  fi
  syntax_check_color $GATEWAY 4 WARN
  if [ $? = 0 ]; then
    echo $GATEWAY > $TMP/SeTgateway
    break;
  fi
 done
fi

if [ "$LOOPBACK" = "no" ]; then
 dialog --title "UTILISER UN SERVEUR DE NOMS ?" --yesno "Accéderez-vous a un serveur \
de noms (DNS) ?" 5 42
 if [ $? = 0 ]; then
  if [ ! "`cat $TMP/SeTns 2> /dev/null`" = "" ]; then
    DNSSAMPLE="`cat $TMP/SeTns 2> /dev/null`"
  elif [ "$GATEWAY" = "" ]; then
    DNSSAMPLE=`echo $IPADDR | cut -f 1-3 -d .`
  else
    DNSSAMPLE=$GATEWAY
  fi
  while [ "$NAMESERVER" = "" ]; do
   cat << EOF > $TMP/tempmsg
Voici votre adresse IP actuelle, votre nom d'hôte complet ainsi que votre nom d'hote :
$IPADDR       $HOSTNM.$DOMAIN    $HOSTNM

Veuillez entrer l'adresse IP du serveur de noms (ou 'DNS') à utiliser, tel que :
$DNSSAMPLE.

Vous pourrez ajouter des serveurs de noms ultérieurement, en éditant /$RESOLV.

Adresse IP du serveur de noms primaire à utiliser (aaa.bbb.ccc.ddd) : 
EOF
   dialog --title "CHOIX DU SERVEUR DE NOMS" --inputbox \
"`cat $TMP/tempmsg`" 17 72 $DNSSAMPLE 2> $TMP/SeTns
   if [ $? = 1 -o $? = 255 ]; then
    rm -f $TMP/tempmsg $TMP/SeTns 
    break
   fi
   NAMESERVER="`cat $TMP/SeTns`"
   rm -f $TMP/tempmsg $TMP/SeTns 
  done
 fi
fi

# Check for existing network driver:
unset DONOTPROBE
if cat /proc/net/dev | grep eth0 1> /dev/null 2> /dev/null ; then
  DONOTPROBE=true 
fi

# Really, this rc.netdevice thing is mostly obsolete except for
# handmade local scripts anyway, these days with udev...
# So, we'll skip it:
DONOTPROBE=true

if [ -d lib/modules/`uname -r` \
     -a ! "$LOOPBACK" = "yes" \
     -a ! -x etc/rc.d/rc.hotplug \
     -a ! "$DONOTPROBE" = "true" \
     -a ! -r /cardfound ]; then
  dialog --title "PROBE FOR NETWORK CARD?" --menu "If you like, we \
can look to see what kind of network card you have in your machine, and \
if we find one create an /etc/rc.d/rc.netdevice script to load the module \
for it at boot time.  There's a slight bit of danger that the probing \
can cause problems, but it almost always works.  If you'd rather configure \
your system manually, you can skip the probing process and edit \
/etc/rc.d/rc.modules or /etc/modules.conf later to have it load the right module." \
16 68 2 \
"probe" "look for network cards to set up" \
"skip" "skip probe;  edit /etc/rc.d/rc.modules later" 2> $TMP/reply
  if [ $? = 1 -o $? = 255 ]; then
    rm -f $TMP/reply
    exit
  fi
  REPLY=`cat $TMP/reply`
  rm -f $TMP/reply
  if [ ! "$REPLY" = "skip" ]; then
    for card in 3c59x 82596 dgrs eepro100 e1000 epic100 hp100 lance \
    ne2k-pci olympic pcnet32 rcpci 8139too 8139cp tlan tulip via-rhine \
    yellowfin natsemi ; do
      chroot . /sbin/modprobe $card 2> /dev/null
      if [ $? = 0 ]; then
        dialog --title "CARD DETECTED" --msgbox "A networking card using \
the $card.o module has been detected." 5 72
        echo "$card" > /cardfound
        break;
      fi
     done
     if [ ! -r /cardfound ]; then
       # Don't probe for com20020, because it doesn't check and will always load.
       # Don't probe for arlan, because it needs irq= to work.
       # Don't probe for com90io or com90xx because they taint the kernel.
       for card in depca ibmtr 3c359 3c501 3c503 3c505 3c507 3c509 3c515 ac3200 \
         abyss acenic at1700 cosa cs89x0 de4x5 de600 \
         de620 dmfe dl2k e2100 eepro eexpress eth16i ewrk3 fealnx hamachi hostess_sv11 \
         hp-plus hp lanstreamer ni5010 ni52 ni65 ns83820 sb1000 sealevel sis900 sk98lin skfp smc-ultra \
         smc9194 smctr starfire sungem sunhme tg3 wd e100 iph5526 lp486e tmspci winbond-840 ; do
         chroot . /sbin/modprobe $card 2> /dev/null
         if [ $? = 0 ]; then
           dialog --title "CARD DETECTED" --msgbox "A networking card using \
the $card.o module has been detected." 5 72
           echo "$card" > /cardfound
           break
         fi
       done
     fi
     if [ ! -r /cardfound ]; then
       dialog --title "NO CARD DETECTED" --msgbox "Sorry, but no network \
card could be probed for on your system.  Some cards (like non-PCI NE2000s) \
must be supplied with the I/O address to use and can't be probed for safely. \
You'll have to try to configure the card later by editing \
/etc/rc.d/rc.modules or recompiling your kernel." 9 70
     fi
  fi
fi

if [ "$LOOPBACK" = "yes" ]; then
  dialog --title "CONFIGURATION DU RÉSEAU TERMINÉE" --yesno "Vos paramètres \
réseau sont maintenant configurés pour utiliser l'interface de \
loopback :

Adresse IP : 127.0.0.1
Masque : 255.255.255.0

Est-ce correct ? Choisissez 'Oui' pour continuer ou 'Non' pour configurer \
le réseau à nouveau." 0 0
  RETVAL=$?
elif [ "$USE_DHCP" = "" ]; then
  while [ 0 ]; do
    dialog --title "CONFIRMER LA CONFIGURATION DU RÉSEAU" \
--ok-label Accepter \
--extra-label Éditer \
--cancel-label Recommencer \
--inputmenu \
"Voici vos paramètres. Pour les confirmer et terminer la configuration \
du réseau, appuyez sur ENTRÉE. Si vous devez effectuer des modifications, \
vous pouvez le faire maitenant (ou bien reconfigurer plus tard avec le \
programme 'netconfig')." \
22 60 12 \
"Nom d'hôte :" "$HOSTNM" \
"Nom de domaine :" "$DOMAIN" \
"Adresse IP :" "$IPADDR" \
"Masque de sous-réseau :" "$NETMASK" \
"Passerelle :" "$GATEWAY" \
"Serveur de noms (DNS) :" "$NAMESERVER" 2> $TMP/tempmsg
    RETVAL=$?
    if [ "$RETVAL" = "3" ]; then
      FIELD=`cat $TMP/tempmsg | cut -f 1 -d : | cut -f 2- -d ' '`
      NEWVAL=`cat $TMP/tempmsg | cut -f 2 -d : | cut -f 2- -d ' '`
      if [ "$FIELD" = "Nom d'hôte" ]; then
        HOSTNM=$NEWVAL
      elif [ "$FIELD" = "Nom de domaine" ]; then
        DOMAIN=$NEWVAL
      elif [ "$FIELD" = "Adresse IP" ]; then
        IPADDR=$NEWVAL
      elif [ "$FIELD" = "Masque de sous-réseau" ]; then
        NETMASK=$NEWVAL
      elif [ "$FIELD" = "Passerelle" ]; then
        GATEWAY=$NEWVAL
      elif [ "$FIELD" = "Serveur de noms (DNS)" ]; then
        NAMESERVER=$NEWVAL
      fi
    else
      break
    fi
  done
else # DHCP was used
  dialog --title "CONFIGURATION DU RÉSEAU TERMINÉE" \
--yesno "Votre réseau est maintenant configuré pour utiliser DHCP :

  Nom d'hôte :            $HOSTNM
  Nom de domaine :        $DOMAIN
  Adresse IP :            (définie par le serveur DHCP)
  Masque reseau :         (défini par le serveur DHCP)
  Passerelle :            (définie par le serveur DHCP)
  Serveur de noms (DNS) : (défini par le serveur DHCP)

Est-ce correct ? Choisissez 'Oui' pour continuer ou 'Non' pour configurer \
le réseau à nouveau." 0 0
  RETVAL=$?
fi

if [ "$RETVAL" = "0" ]; then
  echo $HOSTNM.$DOMAIN > etc/HOSTNAME
  write_config_files
  if [ "$1" = "" ]; then
    dialog --msgbox "Paramètres confirmés. La configuration du réseau est terminée." 6 40
  fi
else
  if [ "$1" = "" ]; then
    dialog --msgbox "Paramètres refusés. Lancez 'netconfig' plus tard pour reconfigurer." 6 60
  fi
fi

exit $RETVAL

