#!/usr/bin/env bash

set -e
TMP=/tmp

# sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n

## Seul root peut lancer 'zer' :
#if [ ! "$(whoami)" = "root" ]; then
#	echo "Seul root peut lancer '$0'."
#	exit 1
#fi

# Si un paramètre est entré :
if [ ! "$1" = "" ]; then
	echo "'$0' permet de synchroniser les paquets installés avec le dépôt de 0"
	echo "pour permettre facilement leur mise à niveau."
	echo "Il s'invoque sans aucun paramètre (pour l'instant)."
	echo "Utilisation : '$0'"
	exit 2
fi

# On nettoie :
rm -f $TMP/*.log
rm -rf $TMP/zer_paquets

# On crée les répertoires d'accueil :
mkdir -p $TMP/zer_paquets

crunch() {
	read TEXTE;
	echo $TEXTE;
}

# L'URL précise du dépôt de paquets : chemin contenant les catégories de paquets
# ('base', 'opt', 'extra', etc.) avec ou sans la barre oblique de fin :
LINUXREPO=${LINUXREPO:-rsync://ftp.igh.cnrs.fr/0linux/0/paquets}

# On se crée d'emblée une liste du dépôt local :
find /var/log/paquets/ -type f -exec basename {} \; | sort > $TMP/local.log

# On crée la liste des paquets distants :
rsync ${LINUXREPO}/* > $TMP/distant.log

# Pour chaque paquet déjà installé sur le système :
cat $TMP/local.log | while read paquet_present; do
	
	# Positionnement des variables pour les paquets présents :
	nom_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
	version_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
	arch_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
	build_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
	
	# On trouve son équivalent à jour dans la liste du serveur :
	grep ${nom_paquet_present} $TMP/$local.log > $TMP/grep_paquet_distant.log 2>/dev/null || true
	
	# Pour chaque correspondance trouvée
	cat $TMP/grep_paquet_distant.log | while read grep_paquet_distant; do
		
		# Si l'occurrence n'est pas vide :
		if [ ! "${grep_paquet_distant}" = "" ]; then
			
			# Positionnement des variables pour les paquets distants :
			nom_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
			version_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
			arch_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
			build_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
		
			# Si les *noms* des paquets sont rigoureusement identiques :
			if [ "${nom_paquet_present}" = "${nom_paquet_distant}" ]; then
				
				# Si l'on trouve plus d'une occurrence exacte, le dépôt local est incorrect, on quitte :
				if [ "$(echo ${paquet_distant} | wc -l)" -gt 1 ]; then
					echo "Erreur fatale : plusieurs versions d'un même paquet ont été détectées."
					echo "Veuillez désinstaller les paquets redondants. '$0' va s'arrêter."
					exit 1
				fi
				
				# Si l'architecture est différente, on a un sérieux problème :
				if [ ! "${arch_paquet_distant}" = "${arch_paquet_present}" ]; then
					echo "Erreur fatale : les architectures ne correspondent pas !"
					echo "'$0' va s'arrêter."
					exit 1
				fi
				
				# Si la version ou le compteur sont différents, on met en attente pour mise à niveau :
				if [ ! "${version_paquet_distant}" = "${version_paquet_present}" -o \
					! "${build_paquet_distant}" = "${build_paquet_present}" ]; then
					echo ${categ}/${paquet_distant} >> $TMP/paquets_a_installer.log
					
					# On crée un message pour l'utilisateur de la forme « paquet 1.0.3 -> 1.2.4 » :
					echo "${categ} : ${nom_paquet_present} ${version_paquet_present}-${build_paquet_present} -> ${version_paquet_distant}-${build_paquet_distant}" >> $TMP/messages_a_installer.log
				fi
			fi
		fi
	done
done





# Pour chaque catégorie du système trouvée :
for categ in $(cat $TMP/categories.log); do
	
	# On télécharge la liste du dépôt et on découpe la liste pour n'avoir
	# plus que les noms des fichiers et on trie dans l'ordre :
	lftp -c "open -e \"ls -R ./${categ}\" ${LINUXREPO}" | \
		crunch | \
		sed -e 's/^\(.*\) \(.*\)$/\2/p' -n \
		> $TMP/${categ}.log
		cat $TMP/${categ}.log | sort > $TMP/${categ}.log
	
	echo "OK"
	exit 0

	# Pour chaque paquet déjà installé sur le système :
	cat $TMP/local.log | while read paquet_present; do
		
		# Positionnement des variables pour réduire les appels à 'pkg*()' :
		nom_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
		version_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
		arch_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
		build_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
		
		# On trouve son équivalent à jour dans la liste du serveur ('grep' ne suffit pas,
		# on doit aussi comparer finement les noms pour éviter de mettre à niveau, par exemple,
		# 'libusb' avec 'libusb-compat') :
		paquet_distant="$(grep ${nom_paquet_present} $TMP/$local.log 2>/dev/null || true)"
		
		# Si l'occurrence n'est pas vide :
		if [ ! "${paquet_distant}" = "" ]; then
			
			# Positionnement des variables pour réduire les appels à 'pkg*()' :
			nom_paquet_distant="$(echo ${paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
			version_paquet_distant="$(echo ${paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
			arch_paquet_distant="$(echo ${paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
			build_paquet_distant="$(echo ${paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
		
			# Si les *noms* des paquets sont rigoureusement identiques :
			if [ "${nom_paquet_present}" = "${nom_paquet_distant}" ]; then
				
				# Si l'on trouve plus d'une occurrence exacte, le dépôt local est incorrect, on quitte :
				if [ "$(echo ${paquet_distant} | wc -l)" -gt 1 ]; then
					echo "Erreur fatale : plusieurs versions d'un même paquet ont été détectées."
					echo "Veuillez désinstaller les paquets redondants. '$0' va s'arrêter."
					exit 1
				fi
				
				# Si l'architecture est différente, on a un sérieux problème :
				if [ ! "${arch_paquet_distant}" = "${arch_paquet_present}" ]; then
					echo "Erreur fatale : les architectures ne correspondent pas !"
					echo "'$0' va s'arrêter."
					exit 1
				fi
				
				# Si la version ou le compteur sont différents, on met en attente pour mise à niveau :
				if [ ! "${version_paquet_distant}" = "${version_paquet_present}" -o \
					! "${build_paquet_distant}" = "${build_paquet_present}" ]; then
					echo ${categ}/${paquet_distant} >> $TMP/paquets_a_installer.log
					
					# On crée un message pour l'utilisateur de la forme « paquet 1.0.3 -> 1.2.4 » :
					echo "${categ} : ${nom_paquet_present} ${version_paquet_present}-${build_paquet_present} -> ${version_paquet_distant}-${build_paquet_distant}" >> $TMP/messages_a_installer.log
				fi
			fi
		fi
	done
done

exit 0

# S'il y a des mises à niveau en attente :
if [ -r $TMP/paquet_a_installer.log ]; then
	NBINSTALLPKG="$(cat $TMP/paquets_a_installer.log | wc -l)"
	if [ "${NBINSTALLPKG}" -gt 0 ]; then
		
		# Si 'eglibc' a changé, on arrête tout et on conseille de mettre à niveau via l'OS autonome :
		if [ "$(grep eglibc $TMP/paquets_a_installer.log)" = "" ]; then
			echo "* ATTENTION *"
			echo ""
			echo "Le paquet critique 'eglibc' a été mis à niveau : cela signifie qu'une"
			echo "nouvelle version de 0 vient de sortir (oui, c'est rare) !"
			echo ""
			echo "Vous devez installer cette nouvelle version de la distribution"
			echo "via l'OS autonome (clé USB, DVD, etc.). 'zer' va s'arrêter."
			exit 0
		fi
		
		# Récapitulatif :
		echo "Il y a ${NBINSTALLPKG} paquets à mettre à niveau :"
		cat $TMP/messages_a_installer.log
		echo ""
		echo -n "Procéder aux mises à niveau (tapez « oui » pour confirmer) ? "
		read CONFIRMUPGRADE;
		
		# Si l'on a confirmation :
		if [ "$(echo ${CONFIRMUPGRADE} | tr '[A-Z]' '[a-z]')" = "oui" ]; then
			
			# S'il y a des installations en attente :
			if [ -r $TMP/paquets_a_installer.log ]; then
				if [ $(cat $TMP/paquets_a_installer.log | wc -l) -gt 0 ]; then
					cat $TMP/paquets_a_installer.log | while read paq; do
										
						# On télécharge chaque paquet :
						if [ ! -r $TMP/zer_paquets/${paq}.cpio ]; then
							wget -c ${LINUXREPO}/${paq}.cpio -O $TMP/zer_paquets/${paq}.cpio.part
							mv $TMP/zer_paquets/${paq}.cpio{.part,}
						fi
						
						# On met à niveau :
						spkadd --quiet $TMP/zer_paquets/${paq}.cpio
					done
				fi
			fi
		
		# Sinon, on quitte simplement :
		else
			# On nettoie :
			rm -f $TMP/*.log
			rm -rf $TMP/zer_paquets
			exit 0
		fi
	fi
else
	echo "Le système est à jour !"
	exit 0
fi

exit 0
