#!/usr/bin/env bash

set -e
TMP=/tmp
CONFIGDIR=/etc/0outils/apps

# sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n

## Seul root peut lancer 'zer' :
#if [ ! "$(whoami)" = "root" ]; then
#	echo "Seul root peut lancer '$0'."
#	exit 1
#fi

# Si un paramètre est entré :
if [ ! "$1" = "" ]; then
	echo "'$0' permet de synchroniser les paquets installés avec les"
	echo "dépôts de 0 pour permettre facilement leur mise à niveau."
	echo "Il s'invoque sans aucun paramètre (pour l'instant)."
	echo ""
	echo "Utilisation : '$0'"
	exit 0
fi

# On nettoie :
rm -f $TMP/*.log
rm -rf $TMP/zer_paquets

crunch() {
	read TEXTE;
	echo $TEXTE;
}

# L'URL précise du dépôt de paquets : chemin contenant les catégories de paquets
# ('base', 'opt', 'extra', etc.) avec ou sans la barre oblique de fin :
LINUXREPO=${LINUXREPO:-rsync://ftp.igh.cnrs.fr/0linux/0/paquets}

# On se crée d'emblée une liste du dépôt local :
find /var/log/paquets/ -type f -exec basename {} \; | sort > $TMP/local.log

# Pour chaque catégorie du système :
for categ in base opt xorg; do
	
	# On crée la liste des paquets distants de la catégorie :
	rsync -a ${LINUXREPO}/${categ}/* | sed -e 's/\(^.*\) \(.*\)\(\.spack$\)/\2/p' -n > $TMP/${categ}.log

	# Pour chaque paquet déjà installé sur le système :
	cat $TMP/local.log | while read paquet_present; do
		
		# On trouve son équivalent par le nom dans la liste du serveur :
		if [ ! "$(grep $(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n $TMP/${categ}.log))" = "" ]; then
			grep $(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n) $TMP/${categ}.log \
				> $TMP/grep_paquet_distant.log 2>/dev/null || true
		else
			continue
		fi
		
		# Pour chaque correspondance trouvée :
		cat $TMP/grep_paquet_distant.log | while read grep_paquet_distant; do
			
			# Si l'occurrence n'est pas vide :
			if [ ! "${grep_paquet_distant}" = "" ]; then
				
				# Positionnement des variables pour les paquets présents :
				nom_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
				version_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
				arch_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
				build_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
		
				# Positionnement des variables pour les paquets distants :
				nom_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
				version_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
				arch_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
				build_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
			
				# Si les *noms* des paquets sont rigoureusement identiques :
				if [ "${nom_paquet_present}" = "${nom_paquet_distant}" ]; then
					
					# Si l'on trouve plus d'une occurrence exacte, le dépôt local est incorrect, on quitte :
					if [ "$(echo ${paquet_distant} | wc -l)" -gt 1 ]; then
						echo "Erreur fatale : plusieurs versions d'un même paquet ont été détectées."
						echo "Veuillez désinstaller les paquets redondants. '$0' va s'arrêter."
						exit 1
					fi
					
					# Si l'architecture est différente, on a un sérieux problème :
					if [ ! "${arch_paquet_distant}" = "${arch_paquet_present}" ]; then
						echo "Erreur fatale : les architectures ne correspondent pas !"
						echo "'$0' va s'arrêter."
						exit 1
					fi
					
					# Si la version ou le compteur sont différents, on met en attente pour mise à niveau :
					if [ ! "${version_paquet_distant}" = "${version_paquet_present}" -o \
						! "${build_paquet_distant}" = "${build_paquet_present}" ]; then
						echo ${categ}/${grep_paquet_distant} >> $TMP/paquets_a_installer.log
						
						# On crée un message pour l'utilisateur de la forme « paquet 1.0.3 -> 1.2.4 » :
						echo "${categ} : ${nom_paquet_present} ${version_paquet_present}-${build_paquet_present} -> ${version_paquet_distant}-${build_paquet_distant}" >> $TMP/messages_a_installer.log
					fi
				fi
			fi
		done
	done
done

# Et pour chaque dépôt de paquets installé :
for appcateg in $CONFIGDIR/*; do
	
	# On crée la liste des paquets distants de la catégorie :
	rsync -a ${LINUXREPO}/apps/$(basename ${appcateg})/* | sed -e 's/\(^.*\) \(.*\)\(\.spack$\)/\2/p' -n > $TMP/$(basename ${appcateg}).log

	# Pour chaque paquet déjà installé sur le système :
	cat $TMP/local.log | while read paquet_present; do
		
		# On trouve son équivalent par le nom dans la liste du serveur :
		if [ ! "$(grep $(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n $TMP/${appcateg}.log))" = "" ]; then
			grep $(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n) $TMP/${appcateg}.log \
				> $TMP/grep_paquet_distant.log 2>/dev/null || true
		else
			continue
		fi
		
		# Pour chaque correspondance trouvée :
		cat $TMP/grep_paquet_distant.log | while read grep_paquet_distant; do
			
			# Si l'occurrence n'est pas vide :
			if [ ! "${grep_paquet_distant}" = "" ]; then
				
				# Positionnement des variables pour les paquets présents :
				nom_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
				version_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
				arch_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
				build_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
		
				# Positionnement des variables pour les paquets distants :
				nom_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
				version_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
				arch_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
				build_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
			
				# Si les *noms* des paquets sont rigoureusement identiques :
				if [ "${nom_paquet_present}" = "${nom_paquet_distant}" ]; then
					
					# Si l'on trouve plus d'une occurrence exacte, le dépôt local est incorrect, on quitte :
					if [ "$(echo ${paquet_distant} | wc -l)" -gt 1 ]; then
						echo "Erreur fatale : plusieurs versions d'un même paquet ont été détectées."
						echo "Veuillez désinstaller les paquets redondants. '$0' va s'arrêter."
						exit 1
					fi
					
					# Si l'architecture est différente, on a un sérieux problème :
					if [ ! "${arch_paquet_distant}" = "${arch_paquet_present}" ]; then
						echo "Erreur fatale : les architectures ne correspondent pas !"
						echo "'$0' va s'arrêter."
						exit 1
					fi
					
					# Si la version ou le compteur sont différents, on met en attente pour mise à niveau :
					if [ ! "${version_paquet_distant}" = "${version_paquet_present}" -o \
						! "${build_paquet_distant}" = "${build_paquet_present}" ]; then
						echo "apps/$(basename ${appcateg})/${grep_paquet_distant}" >> $TMP/paquets_a_installer.log
						
						# On crée un message pour l'utilisateur de la forme « paquet 1.0.3 -> 1.2.4 » :
						echo "$(basename ${appcateg}) : ${nom_paquet_present} ${version_paquet_present}-${build_paquet_present} -> ${version_paquet_distant}-${build_paquet_distant}" >> $TMP/messages_a_installer.log
					fi
				fi
			fi
		done
	done
done

exit 0

# S'il y a des mises à niveau en attente :
if [ -r $TMP/paquet_a_installer.log ]; then
	NBINSTALLPKG="$(cat $TMP/paquets_a_installer.log | wc -l)"
	if [ "${NBINSTALLPKG}" -gt 0 ]; then
		
		# Si 'eglibc' a changé, on arrête tout et on conseille de mettre à niveau via l'OS autonome :
		if [ "$(grep eglibc $TMP/paquets_a_installer.log)" = "" ]; then
			echo "* ATTENTION *"
			echo ""
			echo "Le paquet critique 'eglibc' a été mis à niveau : cela signifie qu'une"
			echo "nouvelle version de 0 vient de sortir (oui, c'est rare) !"
			echo ""
			echo "Vous devez installer cette nouvelle version de la distribution"
			echo "via l'OS autonome (clé USB, DVD, etc.). 'zer' va s'arrêter."
			exit 0
		fi
		
		# Récapitulatif :
		echo "Il y a ${NBINSTALLPKG} paquets à mettre à niveau :"
		cat $TMP/messages_a_installer.log
		echo ""
		echo -n "Procéder aux mises à niveau (tapez « oui » pour confirmer) ? "
		read CONFIRMUPGRADE;
		
		# Si l'on a confirmation :
		if [ "$(echo ${CONFIRMUPGRADE} | tr '[A-Z]' '[a-z]')" = "oui" ]; then
			
			# S'il y a des installations en attente :
			if [ -r $TMP/paquets_a_installer.log ]; then
				if [ $(cat $TMP/paquets_a_installer.log | wc -l) -gt 0 ]; then
					cat $TMP/paquets_a_installer.log | while read paq; do
										
						# On télécharge chaque paquet :
						if [ ! -r $TMP/zer_paquets/${paq}.cpio ]; then
							wget -c ${LINUXREPO}/${paq}.cpio -O $TMP/zer_paquets/${paq}.cpio.part
							mv $TMP/zer_paquets/${paq}.cpio{.part,}
						fi
						
						# On met à niveau :
						spkadd --quiet $TMP/zer_paquets/${paq}.cpio
					done
				fi
			fi
		
		# Sinon, on quitte simplement :
		else
			# On nettoie :
			rm -f $TMP/*.log
			rm -rf $TMP/zer_paquets
			exit 0
		fi
	fi
else
	echo "Le système est à jour !"
	exit 0
fi

exit 0
