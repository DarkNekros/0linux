#!/usr/bin/env bash

set -e
TMP=/tmp
CONFIGDIR=/etc/0outils/apps

# sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n

## Seul root peut lancer 'zer' :
#if [ ! "$(whoami)" = "root" ]; then
#	echo "Seul root peut lancer '$0'."
#	exit 1
#fi

# Si un paramètre est entré :
if [ ! "$1" = "" ]; then
	echo "'$0' permet de synchroniser les paquets installés avec les"
	echo "dépôts de 0 pour permettre facilement leur mise à niveau."
	echo "Il s'invoque sans aucun paramètre (pour l'instant)."
	echo ""
	echo "Utilisation : '$0'"
	exit 0
fi

# On nettoie :
rm -f $TMP/*.log
rm -rf $TMP/zer_paquets

crunch() {
	read TEXTE;
	echo $TEXTE;
}

# L'URL précise du dépôt de paquets : chemin contenant les catégories de paquets
# ('base', 'opt', 'extra', etc.) avec ou sans la barre oblique de fin :
LINUXREPO=${LINUXREPO:-rsync://ftp.igh.cnrs.fr/0linux/0/paquets}

# On se crée d'emblée une liste du dépôt local :
find /var/log/paquets/ -type f -exec basename {} \; | sort > $TMP/local.log

# Pour chaque catégorie du système :
for categ in base opt xorg; do
	
	# On crée la liste des paquets distants de la catégorie :
	rsync -a ${LINUXREPO}/${categ}/* | sed -e 's/\(^.*\) \(.*\)\(\.spack$\)/\2/p' -n > $TMP/${categ}.log

	# Pour chaque paquet déjà installé sur le système :
	cat $TMP/local.log | while read paquet_present; do
		
		# Si on trouve son équivalent par le nom dans la liste du serveur :
		if [ ! "$(grep $(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n) $TMP/${categ}.log)" = "" ]; then
			grep $(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n) $TMP/${categ}.log \
				> $TMP/grep_paquet_distant.log 2>/dev/null || true
			
			# Pour chaque correspondance trouvée :
			cat $TMP/grep_paquet_distant.log | while read grep_paquet_distant; do
				
				# Si l'occurrence n'est pas vide :
				if [ ! "${grep_paquet_distant}" = "" ]; then
					
					# Positionnement des variables pour les paquets présents :
					nom_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
					version_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
					arch_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
					build_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
			
					# Positionnement des variables pour les paquets distants :
					nom_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
					version_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
					arch_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
					build_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
				
					# Si les *noms* des paquets sont rigoureusement identiques :
					if [ "${nom_paquet_present}" = "${nom_paquet_distant}" ]; then
						
						# Si l'on trouve plus d'une occurrence exacte, le dépôt local est incorrect, on quitte :
						if [ "$(echo ${paquet_distant} | wc -l)" -gt 1 ]; then
							echo "Erreur fatale : plusieurs versions d'un même paquet ont été détectées."
							echo "Veuillez désinstaller les paquets redondants. '$0' va s'arrêter."
							exit 1
						fi
						
						# Si l'architecture est différente, on a un sérieux problème :
						if [ ! "${arch_paquet_distant}" = "${arch_paquet_present}" ]; then
							echo "Erreur fatale : les architectures ne correspondent pas !"
							echo "'$0' va s'arrêter."
							exit 1
						fi
						
						# Si la version ou le compteur sont différents, on met en attente pour mise à niveau :
						if [ ! "${version_paquet_distant}" = "${version_paquet_present}" -o \
							! "${build_paquet_distant}" = "${build_paquet_present}" ]; then
							echo ${categ}/${grep_paquet_distant} >> $TMP/paquets_a_installer.log
							
							# On crée un message pour l'utilisateur de la forme « paquet 1.0.3 -> 1.2.4 » :
							echo "${categ} : ${nom_paquet_present} ${version_paquet_present}-${build_paquet_present} -> ${version_paquet_distant}-${build_paquet_distant}" >> $TMP/messages_a_installer.log
						fi
					fi
				fi
			done
		# Si aucune occurrence n'a été trouvée, on passe à l'itération suivante :
		else
			continue
		fi
	done
done

# Et pour chaque dépôt de paquets installé :
for appcateg in $CONFIGDIR/*; do
	
	# On crée la liste des paquets distants de la catégorie :
	rsync -a ${LINUXREPO}/apps/$(basename ${appcateg})/* | sed -e 's/\(^.*\) \(.*\)\(\.spack$\)/\2/p' -n > $TMP/$(basename ${appcateg}).log

	# Pour chaque paquet déjà installé sur le système :
	cat $TMP/local.log | while read paquet_present; do
		
		# Si on trouve son équivalent par le nom dans la liste du serveur :
		if [ ! "$(grep $(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n) $TMP/${appcateg}.log)" = "" ]; then
			grep $(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n) $TMP/${appcateg}.log \
				> $TMP/grep_paquet_distant.log 2>/dev/null || true
				
			# Pour chaque correspondance trouvée :
			cat $TMP/grep_paquet_distant.log | while read grep_paquet_distant; do
				
				# Si l'occurrence n'est pas vide :
				if [ ! "${grep_paquet_distant}" = "" ]; then
					
					# Positionnement des variables pour les paquets présents :
					nom_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
					version_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
					arch_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
					build_paquet_present="$(echo ${paquet_present} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
			
					# Positionnement des variables pour les paquets distants :
					nom_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\1/p' -n)"
					version_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\2/p' -n)"
					arch_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\3/p' -n)"
					build_paquet_distant="$(echo ${grep_paquet_distant} | sed 's/\(.*\)-\(.*\)-\(.*\)-\(.*\)$/\4/p' -n)"
				
					# Si les *noms* des paquets sont rigoureusement identiques :
					if [ "${nom_paquet_present}" = "${nom_paquet_distant}" ]; then
						
						# Si l'on trouve plus d'une occurrence exacte, le dépôt local est incorrect, on quitte :
						if [ "$(echo ${paquet_distant} | wc -l)" -gt 1 ]; then
							echo "Erreur fatale : plusieurs versions d'un même paquet ont été détectées."
							echo "Veuillez désinstaller les paquets redondants. '$0' va s'arrêter."
							exit 1
						fi
						
						# Si l'architecture est différente, on a un sérieux problème :
						if [ ! "${arch_paquet_distant}" = "${arch_paquet_present}" ]; then
							echo "Erreur fatale : les architectures ne correspondent pas !"
							echo "'$0' va s'arrêter."
							exit 1
						fi
						
						# Si la version ou le compteur sont différents, on met en attente pour mise à niveau :
						if [ ! "${version_paquet_distant}" = "${version_paquet_present}" -o \
							! "${build_paquet_distant}" = "${build_paquet_present}" ]; then
							echo "apps/$(basename ${appcateg})/${grep_paquet_distant}" >> $TMP/paquets_a_installer.log
							
							# On crée un message pour l'utilisateur de la forme « paquet 1.0.3 -> 1.2.4 » :
							echo "$(basename ${appcateg}) : ${nom_paquet_present} ${version_paquet_present}-${build_paquet_present} -> ${version_paquet_distant}-${build_paquet_distant}" >> $TMP/messages_a_installer.log
						fi
					fi
				fi
			done
		# Si aucune occurrence n'a été trouvée, on passe à l'itération suivante :
		else
			continue
		fi
	done
done

exit 0

# S'il y a des mises à niveau en attente :
if [ -r $TMP/paquet_a_installer.log ]; then
	NBINSTALLPKG="$(cat $TMP/paquets_a_installer.log | wc -l)"
	if [ "${NBINSTALLPKG}" -gt 0 ]; then
		
		# Si 'eglibc' a changé, on arrête tout et on conseille de mettre à niveau via l'OS autonome :
		if [ "$(grep eglibc $TMP/paquets_a_installer.log)" = "" ]; then
			echo "* ATTENTION *"
			echo ""
			echo "Le paquet critique 'eglibc' a été mis à niveau : cela signifie qu'une"
			echo "nouvelle version de 0 vient de sortir (oui, c'est rare) !"
			echo ""
			echo "Vous devez installer cette nouvelle version de la distribution"
			echo "via l'OS autonome (clé USB, DVD, etc.). 'zer' va s'arrêter."
			exit 0
		fi
		
		# Récapitulatif :
		echo "Il y a ${NBINSTALLPKG} paquets à mettre à niveau :"
		cat $TMP/messages_a_installer.log
		echo ""
		echo -n "Procéder aux mises à niveau (tapez « oui » pour confirmer) ? "
		read CONFIRMUPGRADE;
		
		# Si l'on a confirmation :
		if [ "$(echo ${CONFIRMUPGRADE} | tr '[A-Z]' '[a-z]')" = "oui" ]; then
			
			# S'il y a des installations en attente :
			if [ -r $TMP/paquets_a_installer.log ]; then
				if [ $(cat $TMP/paquets_a_installer.log | wc -l) -gt 0 ]; then
					cat $TMP/paquets_a_installer.log | while read paq; do
										
						# On télécharge chaque paquet :
						if [ ! -r $TMP/zer_paquets/${paq}.cpio ]; then
							wget -c ${LINUXREPO}/${paq}.cpio -O $TMP/zer_paquets/${paq}.cpio.part
							mv $TMP/zer_paquets/${paq}.cpio{.part,}
						fi
						
						# On met à niveau :
						spkadd --quiet $TMP/zer_paquets/${paq}.cpio
					done
				fi
			fi
		
		# Sinon, on quitte simplement :
		else
			# On nettoie :
			rm -f $TMP/*.log
			rm -rf $TMP/zer_paquets
			exit 0
		fi
	fi
else
	echo "Le système est à jour !"
	exit 0
fi

exit 0
