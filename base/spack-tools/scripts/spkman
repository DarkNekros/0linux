#!/bin/sh
#
# SPKMAN - manage the Slackware(R) compatible CPIO-based packages.
#

# Copyright (c) 2010 SÃ©bastien Boillod <sbb at tuxfamily dot org>.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# === Library ==================================================================
eat () {
    # Return the amount of main arguments to shift and reset the index.
    # $f
    r__=$1; shift 1; ARGV="$*"
}

cpiocheck () {
    # Check the CPIO archive integrity checking size report...
    # $f STDERR BUFFER FILE, CHECKED FILE(S)
    local buffer="$1"; shift 1
    awk '{E=1}/^[0-9]+/{E=0}{exit E}' "$buffer" && return 0 # we should only have size here..
    local list="$(echo "$*" | sed 's/ /, /g;s/$/ file/;s/,\([^,]*\)$/ and\1s/')"
    growl -1 "The package is corrupted (check $list)."
    return 1
}

dirscout () {
    # Prevent problems with directory install.
    # $f DRY RUN
    local dry="$1"
    while read d; do
        [ -d "$d" ] && continue # directory is ok...
        [ ! -h "$d" -a ! -e "$d" ] && continue # not exist and not a broken symlink is also ok...
        growl 0 "\"$d\" is not a directory as expected. Remove it..."
        [ $dry -eq 0 ] && rm -f "$d"
    done
}

filecheck () {
    # Check the file meet CPIO package specification.
    # $f FILE
    local spec="$(basename $1 | awk '/[^-]+-[^-]+-[^-]+-[^-]+.cpio$/{print 0;exit}{print 1}')"
    if [ ! -f "$1" ]; then
        growl -1 "\"$1\" is not a regular file."
        return 1
    elif [ $spec -ne 0 ]; then
        growl -1 "\"$1\" is not a well-formatted CPIO package name."
        return 2
    fi
    return 0
}

fileregister () {
    # Make the file & directory lists attached to the package.
    # $f PACKAGE, DIRECTORY LIST, FILE LIST, SYMLINK LIST, FORMATTED MAN LIST
    local log="$PKGLOG/$1" dirs="$2" files="$3" cats="$4" links="$5"
    awk -v CATS="$cats" -v DIRS="$dirs" -v FILES="$files" \
        '(FNR == 1){if(NR>1)DELFILE=ARGV[1];STORE = 0}
         (FILENAME == DELFILE){next}
         (STORE < 1){if ($0 ~ /^FILE LIST:/) STORE = length(DELFILE) > 0? 1 : 2; next }
         (STORE < 2){delete DEL[$0]; next}
         {DEL[$0]}
         END{ for(i in DEL){ if (i ~ /\/$/){print i>DIRS;continue}
                            print i >FILES
                            if(sub(/\/man.\/[^/]+$/,"///&",i) && sub(/\/\/+man/, "/cat",i)) print i >CATS
                          }
              close(DIRS);close(FILES);close(CATS) }' "$log" "$PKGLOG/"* "$links"
}

filescout () {
    # Prevent problems with file install.
    # $f DRY RUN
    local dry="$1"
    awk '{print; print >"/dev/stderr"}' 2>"$TMPDIR/files" | while read f; do
        [ -d "$f" ] || continue
        growl 0 "found a \"$f\" directory where a file was expected. Remove it..."
        [ $dry -eq 0 ] && rm -rf "$f"
    done
}

growl () {
    # Print error message on stderr and exits if positive code is given.
    # $f CODE, MESSAGE
    local err=$1 pr='(E)'; shift 1
    if [ "$1" ]; then
        # If there is a second argument, we print arguments with 'echo'.
        [ $err -eq 0 ] && pr='(W)'
        echo "$pr $*" 1>&2
    else
        # Otherwise we use 'cat' and print stdin.
        cat <&0 >&2
    fi
    [ $err -le 0 ] || exit $err
}

linkregister () {
    # Print the link list attached to the package, storing the others.
    # $f PACKAGE, KEPT LINK LIST
    local log="$SCRIPTLOG/$1" logc=$(ls -1 "$SCRIPTLOG"| wc -l) kept="$2"
    echo "FILE LIST:" >"$kept"
    [ $logc -gt 0 ] || return 1 # no more script left...
    [ -s "$log" ] || log="/dev/null" # no valid script attached to the package...
    awk 'BEGIN{C=0;STORE= (ARGV[1] == "/dev/null") ? 0 : 1}
         (++C != FNR){if(STORE > 0)DELFILE=ARGV[1];C=FNR;STORE = 0}
         (FILENAME == DELFILE){next}
         {LINK=0}
         /^\( *cd *[^ \t]+ *; *rm -rf *[^ \t]+ *\)*$/{$0=$3"/"$7;LINK++}
         (LINK < 1){next}
         (STORE > 0) {DEL[$0]; next}
         ($0 in DEL){delete DEL[$0]; next}
         {print $0 >"/dev/stderr"}
         END{for(i in DEL) print i}' "$log" "$SCRIPTLOG/"* 2>>"$kept" | sort
}

logfmt () {
    # Format the log of the installed package
    # $f DRY RUN, NAME, LOCATION
    local dry=$1 name=$2 path="$3" short="$(shorty "$3"| sed 's/+/\\+/g')" # "+" must be escaped for AWK.
    if [ $dry -ne 0 ]; then
        exec 4>&3
    else
        exec 4>"$PKGLOG/$name"
    fi
    ( cd "$TMPDIR"
        echo "PACKAGE NAME: $name" >&4
        awk -v POST="$(du -k ./post-install.sh 2>/dev/null)" -v PRE="$(du -k ./pre-install.sh)" \
            '(NR==1){ZSIZE=$1;}(NR==2){SIZE=$1}
             END{RSIZE = 60 * (NR-2) / 512 # empty directory = 60bits
                sub(/[^0-9]*$/,"",POST); sub(/[^0-9]*$/,"",PRE)
                print "COMPRESSED SIZE: " int(ZSIZE/2) "K"
                print "UNCOMPRESSED SIZE: " int((SIZE+RSIZE)/2-PRE+POST) "K"}' ./zsize ./size ./dirs >&4
        echo "PACKAGE LOCATION: $path" >&4
        echo "PACKAGE DESCRIPTION:" >&4
        [ -r ./about.txt ] && awk '(L > 10){exit}/^'"$short"':/{L++;print;next}(L>0){exit}' ./about.txt >&4
        echo "FILE LIST:" >&4
        echo "./" >&4 # meet the Slackware spec.
        sort ./dirs ./files >&4 ) 
    exec 4>&- 
}

pathinit () {
    # Initialize required paths
    # $f 
    local r="$ROOT/var/log"
    PKGLOG="$r/packages"; RMPKGLOG="$r/removed_packages";
    SCRIPTLOG="$r/scripts"; RMSCRIPTLOG="$r/removed_scripts"
    mkdir -p "$PKGLOG" "$RMPKGLOG" "$SCRIPTLOG" "$RMSCRIPTLOG"
    TMPDIR="$(mktemp -d "$ROOT/tmp-$$-XXXXXX" 2>/dev/null)"
    [ "$TMPDIR" ] || growl 1 "Can't create secure temporary directory."
}

pkginstall () {
    # Install the given package(s).
    # $f FORCE REINSTALL, DRY RUN, PACKAGE
    local re=$1 dry=$2 name="$(basename "$3" .cpio)" cpio="$3" unzip="xz -d -c"
    filecheck "$cpio" || return 1
    echo "================================================================================" >&3
    echo "Installing the $name package..."
    echo "================================================================================" >&3
    [ ! -f "$PKGLOG/$name" ] || (growl $((1 - $re)) "\"$name\" is already installed.") || return 2
    local files=$(cpio --quiet -t "files.?z" <"$cpio") post="$TMPDIR/post-install.sh"
    if [ "$files" = "files.gz" ]; then
        unzip="gzip -d -c"
    elif [ ! "$files" = "files.xz" ]; then
        (growl 1 "Broken package: neither \"files.xz\" nor \"files.gz\" found inside.") || return 1
    fi
    preinstall $dry "$cpio" <"$cpio" || return 1
    echo "  checking the file archive..." >&3
    cpio -i --to-stdout "$files" < "$cpio" 2>"$TMPDIR/zsize"| $unzip 2>/dev/null \
                              | cpio -t 2>"$TMPDIR/size"| filescout $dry
    cpiocheck "$TMPDIR/zsize" "$files"|| return 1 # just skip the package.
    [ -s  "$TMPDIR/files" ] || (growl 1 "Broken package: can't get files from \"$files\".") || return 1
    logfmt $dry "$name" "$cpio"
    echo "  installing the files..." >&3
    [ $dry -eq 0 ] || return 0
    (cd "$ROOT/"; cpio --quiet -i --to-stdout "$files" | $unzip | cpio --quiet -m -i -u) < "$cpio" || return 1
    if [ -s "$post" ]; then
        # We copy the script now, for the remove to have new links during the upgrades.
        cp -f "$post" "$SCRIPTLOG/$name"
        chmod 755 "$SCRIPTLOG/$name"
    else
        return 0
    fi
}

pkgmatch () {
    # Return the name of the packages that match the pattern.
    # $f INSTALL MODE, UPGRADE MODE, PATTERN
    local imode=$1 umode=$2 name="$3" pat="$(basename "$3" .cpio)"
    if [ $umode -eq 0 -a -f "$PKGLOG/$pat" ]; then
        # true remove mode, we first test precise package.
        echo "$pat"
        return 0
    elif [ $umode -ne 0 -a -f "$name" ]; then
        # upgrade, we match installed version of the package.
        pat=$(shorty "$name")
    fi
    # Here pattern is interpreted as a package base name...
    pat="$(ls -1 "$PKGLOG" | sed "/^$pat-[^-][^-]*-[^-][^-]*-[^-][^-]*$/p" -n)"
    if [ "$pat" ]; then
        echo "$pat"
    elif [ $(($umode + $imode)) -lt 2 ]; then
        # We are not in "upgrade or install new" mode...
        growl -1 "No matching installed package for the \"$name\" removing request."
        imode=$((($imode-1)*-1)) # return 0 if we are in "remove then install" mode...
        return $imode
    fi
    return 0
}

pkgremove () {
    # Remove the given package(s).
    # $f DRY RUN, UPGRADE CONTEXT, PACKAGE(S)
    local dry=$1 up=$2 stamp=""; shift 2
    while [ $# -gt 0 ]; do
        echo "================================================================================" >&3
        echo "Removing the \"$1\" package..."
        echo "================================================================================" >&3
        rm -f "$TMPDIR/files" "$TMPDIR/dirs" "$TMPDIR/symkept" "$TMPDIR/cats"
        touch "$TMPDIR/files" "$TMPDIR/dirs" "$TMPDIR/symkept" "$TMPDIR/cats"
        linkregister "$1" "$TMPDIR/symkept" | while read -r link; do
            if [ -h "$ROOT/$link" ]; then
                echo "  unlink  $link" >&3
                [ $dry -gt 0 ] || rm -f "$ROOT/$link"
            else
                growl 0 "Can't unlink \"$link\" (missing or not a symbolic link)."
            fi
        done
        fileregister "$1" "$TMPDIR/dirs" "$TMPDIR/files" "$TMPDIR/cats" "$TMPDIR/symkept"
        sort "$TMPDIR/files" | while read -r file; do
            if [ -f "$ROOT/$file" ]; then
                echo "  delete    (file)     $file" >&3
                [ $dry -gt 0 ] || rm -f "$ROOT/$file"
            else
                growl 0 "Can't delete \"$file\" (missing or not a regular file)."
            fi
        done
        sort "$TMPDIR/cats" | while read -r cat; do
            [ -f "$ROOT/$cat" ] || continue
            echo "  delete    (file)     $cat" >&3
            [ $dry -gt 0 ] || rm -f "$ROOT/$cat"
        done
        sort -r "$TMPDIR/dirs" | while read -r dir; do
            if [ -d "$ROOT/$dir" ]; then
                echo "  delete  (directory)  $dir" >&3
                [ $dry -gt 0 ] || rmdir "$ROOT/$dir" 2>/dev/null || growl 0 "\"$dir\" is not empty. Won't be deleted..."
            else
                growl 0 "Can't delete \"$dir\" (missing or not a directory)."
            fi
        done
        [ $up -eq 0 ] || stamp=$(date "+-upgraded-%Y-%m-%d,%T")
        [ $dry -gt 0 ] || mv -f "$PKGLOG/$1" "$RMPKGLOG/$1$stamp"
        [ $dry -gt 0 -o ! -f "$SCRIPTLOG/$1" ] || mv -f "$SCRIPTLOG/$1" "$RMSCRIPTLOG/$1$stamp"
        shift 1
    done
}

postinstall () {
    # Perform the post-install operations.
    # $f DRY RUN
    local dry=$1 post="$TMPDIR/post-install.sh"
    echo "  executing the post-install script..." >&3
    if [ $dry -ne 0 ]; then
        [ -O /sbin/ldconfig -a -x /sbin/ldconfig ] && /sbin/ldconfig # user may not be root during tests & debugs...
        (cd "$ROOT/" && sh "$post")
    else
        return 0
    fi
}

preinstall () {
    # Preinstall the package, initializing the tree.
    # $f DRY RUN, PACKAGE NAME
    local dry=$1 name="$2"
    rm -f "$TMPDIR/"* # remove potential content of a previous install
    ( cd "$TMPDIR"
        cpio -i about.txt post-install.sh pre-install.sh <&0 2>./size
        cpiocheck ./size about.txt post-install.sh pre-install.sh || return 1
        [ -r ./about.txt ] && whatabout "$name" < ./about.txt >&3
        echo "  building the directory tree..." >&3
        sed '/^mkdir/{s/^[^"]*"\|" *$//g;s/\\\\/"ESC/g;s/\([^\\]\)" "/\1\n/g;s/\\//g;s/"ESC/\\/g;p}' \
           -n ./pre-install.sh 2>/dev/null >./dirs  # we format the list of directories
           if [ ! -s ./dirs ]; then
               growl 1 "Broken or missing pre-install.sh script."
           fi) || return 1
        ( cd "$ROOT/" 
        dirscout $dry < "$TMPDIR/dirs"
        [ $dry -ne 0 ] || sh "$TMPDIR/pre-install.sh" ) || return 1
}

shorty () {
    # Return the short "soft-version" name of the package.
    # $f NAME
    basename "$1" .cpio | sed "s/\(.*\)-[^-][^-]*-[^-][^-]*-[^-][^-]*$/\1/p" -n
}

tmpclear () {
    # Wipe out the current and not more used temporary directories.
    # $f DEBUG MODE
    [ $1 -ne 0 ] || rm -rf "$TMPDIR"
    find $ROOT/ -maxdepth 1 -type d -name "tmp-*-??????" | while read tmp; do
        # we remove dirs without attached pid or older than 24h.
        pid="$(basename "$tmp" | cut -f 2 -d "-")"
        [ ! -e "/proc/$pid" -o "$(find "$tmp/" -maxdepth 0 -mtime +1)" ] || continue
        rm -rf "$tmp"
    done
}

usage () {
    # Print the help digest, then exit
    # $f CODE
    local out=1 code="$1"
    [ $code -eq 0 ] || out=2
    cat >&$out << HELP
spkman - manage the Slackware(R) compatible CPIO-based packages.

    Spkman install, remove or upgrade the packages requested or given on the
    command line. In order to be installed or upgraded, the packages must meet
    the standard Slackware(R) naming pattern: "name-version-architecture-build"
    and bear a ".cpio" extension. Otherwise, for removing you can just give the
    "name-version" base names, each matching installed package will then be
    wiped out.

    By default, spkman just prints the description of the given packaged
    softwares.

    Usage: spkman <package(s)|name(s)> [option(s)|action(s)]

    Options:

        -f, --force     ---     install a package even if it is already
                                installed. Has no effect during upgrade.
        -g, --debug     ---     do not remove intermediate files attached to the
                                current process.
        -h, --help      ---     print this help on stdout then exit.
        -i, --install   ---     install the given packages. Can be combined with
                                the remove action to reinstall the packages
                                properly.
        -q, --quiet     ---     reduce the output to the strict necessary.
        -r, --remove    ---     remove the given packages.
        --root=<dir>    ---     use <dir> as root instead of "/".
        -u, --upgrade   ---     replace previous versions of the packages with
                                these ones. When combined with the install
                                action, install the packages even if they have
                                no previous installed version. When combined
                                with the remove action, attempt to remove the
                                packages even if they have no installable
                                counterpart.
        -y, --dry-run   ---     do not really perform actions, just try to show
                                what would be produce if it was the case.


    Bug reports, suggestions, feedbacks, questions, and so on, should be sent to
    Seb (author/maintainer, the license -- MIT/X11 -- is at the head of the
    script) here: <sbb at tuxfamily dot org>.

HELP
    exit $code
}

whatabout () {
    # Print the "about" description of the package.
    # $f PACKAGE NAME
    local name="$(shorty "$1" | sed 's/+/\\+/g')"
    awk '(sub(/^'"$name"':/,"")){BREAK = sub(/[^ \t]/, "&") ? 0 : BREAK+1;
                if (BREAK > 1) exit 0; print "*"$0}'
}

# === Main =====================================================================
umask 022
export LC_ALL="C" # ensure the command outputs won't be changed by the locale.
unset ARGV TMPDIR PKGLOG SCRIPTLOG RMPKGLOG RMSCRIPTLOG ROOT
debug=0
dry=0
force=0
imode=0
rmode=0
umode=0
exec 3>&1
r__=0
for arg in "$@"; do
    case "$arg" in
        -f|--force) force=1 ;;
        -g|--debug) debug=1 ;;
        -h|--help) usage 0 ;;
        -i|--install) imode=1 ;;
        -q|--quiet) exec 3>"/dev/null" ;;
        -r|--remove) rmode=1 ;;
        -u|--upgrade) umode=1 ;;
        -y|--dry-run) dry=1 ;;
        --root=?*) ROOT="$(echo "$arg" | cut -f 2- -d "=")" ;;
        -*) growl 1 "\"$arg\" is not a valid option." ;;
        *) ARGV="$ARGV $r__"; r__=0;;
    esac
    r__=$(($r__+1))
done
# Define some handy shortcuts for mode-mix resolution...
uimode=$(($imode + $umode))
urmode=$(($rmode + $umode))
allmode=$(($rmode + $umode + $imode))

[ "$ARGV" ] || usage 1

[ $allmode -eq 0 ] || pathinit

arg=""
while [ "$ARGV" ]; do
    eat $ARGV; shift $r__
    if [ $allmode -eq 0 ]; then
        filecheck "$1" && cpio -i --quiet --to-stdout about.txt <"$1" | whatabout "$1" # default action.
        continue
    fi
    [ $urmode -eq 0 ] || arg="$(pkgmatch $imode $umode "$1")" || continue
    if [ $umode -eq 0 ]; then
        [ "$arg" ] && pkgremove "$dry" 0 $arg
        [ $imode -eq 0 ] || pkginstall "$force" "$dry" "$1" || continue
    else
        pkginstall 0 "$dry" "$1" || [ $? -ne 2 -a $rmode -ne 0 ] || continue
        [ "$arg" ] && pkgremove "$dry" 1 $arg
    fi
    [ $uimode -eq 0 -o ! -s "$TMPDIR/post-install.sh" ] || postinstall "$dry"
done
[ "$TMPDIR" ] && tmpclear $debug
exec 3>&-

# EoF
